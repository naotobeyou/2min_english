<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>éŸ³å£°é€šè©±</title>
  <link rel="stylesheet" href="/css/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<div class="card call-card">

  <!-- ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ï¼‹ã‚¿ã‚¤ãƒãƒ¼ -->
  <div class="profile-timer-wrapper">
    <!-- ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å·¦å´ -->
    <div class="profile-left">
      <img src="/uploads/<%= partner.avatar || 'default.png' %>" class="avatar-large" alt="ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒ">
      <ul class="profile-list">
        <li><strong>åå‰:</strong> <%= partner.username %></li>
        <li><strong>è¶£å‘³:</strong> <%= partner.hobbies || 'æœªè¨­å®š' %></li>
        <li><strong>ç›®çš„:</strong> <%= partner.purpose || 'æœªè¨­å®š' %></li>
        <li><strong>è‹±èªãƒ¬ãƒ™ãƒ«:</strong> <%= partner.level %></li>
      </ul>
    </div>

    <!-- ã‚¿ã‚¤ãƒãƒ¼ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å³å´ -->
    <div class="timer-right">
      <p id="status">éŸ³å£°é€šè©±ã‚’æº–å‚™ä¸­...</p>
      <div id="timer" class="timer">02:00</div>
      <p id="extensionInfo" class="text-sm">å»¶é•·å¯èƒ½å›æ•°: 2å›</p>
      <button id="extendBtn" class="btn btn-secondary" style="display: none;">å»¶é•·ã™ã‚‹</button>
    </div>
  </div>

  <!-- è©±é¡Œã‚«ãƒ¼ãƒ‰ -->
  <div class="topic-card">
    <select id="topicSelect" class="input">
      <option value="">-- è©±é¡Œã‚’é¸ã‚“ã§ãã ã•ã„ --</option>
      <option value="é€±æœ«ã¯ä½•ã‚’ã—ã¦éã”ã™ã®ãŒå¥½ãï¼Ÿ">é€±æœ«ã¯ä½•ã‚’ã—ã¦éã”ã™ã®ãŒå¥½ãï¼Ÿ</option>
      <option value="æœ€è¿‘è¦‹ãŸæ˜ ç”»ã§é¢ç™½ã‹ã£ãŸã®ã¯ï¼Ÿ">æœ€è¿‘è¦‹ãŸæ˜ ç”»ã§é¢ç™½ã‹ã£ãŸã®ã¯ï¼Ÿ</option>
      <option value="è‹±èªã‚’å­¦ã¶ãã£ã‹ã‘ã¯ï¼Ÿ">è‹±èªã‚’å­¦ã¶ãã£ã‹ã‘ã¯ï¼Ÿ</option>
      <option value="ã‚‚ã—ã©ã“ã§ã‚‚ä½ã‚ã‚‹ãªã‚‰ã€ã©ã“ã‚’é¸ã¶ï¼Ÿ">ã‚‚ã—ã©ã“ã§ã‚‚ä½ã‚ã‚‹ãªã‚‰ã€ã©ã“ã‚’é¸ã¶ï¼Ÿ</option>
      <option value="å­ã©ã‚‚ã®ã“ã‚ã®å¤¢ã¯ï¼Ÿ">å­ã©ã‚‚ã®ã“ã‚ã®å¤¢ã¯ï¼Ÿ</option>
    </select>
    <button id="sendTopicBtn" class="btn btn-secondary">ã“ã®è©±é¡Œã«ã™ã‚‹</button>
    <p id="topicDisplay" class="text-lg bold"></p>
    <p id="topicNotice" class="text-sm gray"></p>
  </div>

  <!-- ãƒœã‚¿ãƒ³é¡ -->
  <div class="control-buttons">
    <button id="pauseBtn" class="btn btn-secondary">â¸ï¸ ä¸€æ™‚åœæ­¢</button>
    <button id="resumeBtn" class="btn btn-secondary" style="display:none;">â–¶ï¸ å†é–‹</button>
    <button id="endCallBtn" class="btn btn-primary end-btn" disabled>é€šè©±ã‚’çµ‚äº†ã™ã‚‹</button>
  </div>

  <!-- æ®‹ã‚Šæ™‚é–“ -->
  <div class="pause-info">
    <div id="pause-status"><span id="pause-label"></span></div>
    <p id="myPauseTime">â¸ï¸ ã‚ãªãŸã®æ®‹ã‚Š: <span id="myPauseTimeLeft">2:00</span></p>
    <p id="partnerPauseTime">â¸ï¸ ç›¸æ‰‹ã®æ®‹ã‚Š: <span id="partnerPauseTimeLeft">2:00</span></p>
  </div>

</div>




<audio id="remoteAudio" autoplay></audio>
<script src="/socket.io/socket.io.js"></script>

  <script src="/js/call.js"></script>
  <script>
    const roomId = "<%= roomId %>";

    // âœ… é€šè©±çµ‚äº†å¾Œã€endç”»é¢ã«é·ç§»
async function endCall() {


  if (window.__callEnded) return;
  window.__callEnded = true;
  console.log('â–¶ï¸ é€šè©±çµ‚äº†å‡¦ç†ã‚’é–‹å§‹');

  // éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯åœæ­¢
  if (peer?.getSenders) {
    try {
      peer.getSenders().forEach(sender => {
        sender.track?.stop();
      });
    } catch (e) {
      console.warn("éŸ³å£°ãƒˆãƒ©ãƒƒã‚¯åœæ­¢ä¸­ã«ä¾‹å¤–:", e);
    }
  }

  clearInterval(timerInterval);
  socket.emit('force-end', roomId);

  try {
    const response = await fetch('/mark-ended', {
      
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ roomId })
    });

    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    console.log(`âœ… /mark-ended æˆåŠŸï¼šRoom ${roomId} çµ‚äº†ãƒãƒ¼ã‚¯å®Œäº†`);

    window.location.href = `/end/${roomId}`;
  } catch (err) {
    console.error('âŒ /mark-ended é€šä¿¡ã‚¨ãƒ©ãƒ¼:', err);
    alert('é€šè©±ã®çµ‚äº†å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«æˆ»ã‚Šã¾ã™ã€‚');
    window.location.href = '/dashboard';
  }
}

        document.getElementById('endCallBtn').addEventListener('click', endCall);

        const socket = io();
    const userId = "<%= user._id %>";
    socket.emit('join-waiting', userId);

    const peer = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    const endCallBtn = document.getElementById('endCallBtn');
    const statusEl = document.getElementById('status');
    const timerDisplay = document.getElementById('timer');
    const extendBtn = document.getElementById('extendBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const pauseHint = document.getElementById('pauseHint');
    const topicSelect = document.getElementById('topicSelect');
    const sendTopicBtn = document.getElementById('sendTopicBtn');
    const topicDisplay = document.getElementById('topicDisplay');
    const topicNotice = document.getElementById('topicNotice');
    const micSelect = document.getElementById('micSelect');
    const speakerSelect = document.getElementById('speakerSelect');
    const speakerVolumeSlider = document.getElementById('speakerVolume');
    const remoteAudio = document.getElementById('remoteAudio');

    let currentStream;
    let remaining = 120;
    let timerInterval;
    let extensionCount = 0;
    let extensionRequested = false;
    let extensionReceived = false;
    let extensionApprovals = 0;
    let timerPaused = false;
    let remainingPauseTime = 120;
    let pauseInterval;
    let topicLock = false;

    function startTimer() {
      timerInterval = setInterval(() => {
        if (timerPaused) return;

        const min = String(Math.floor(remaining / 60)).padStart(2, '0');
        const sec = String(remaining % 60).padStart(2, '0');
        timerDisplay.textContent = `${min}:${sec}`;

        if (remaining === 30 && extensionCount < 2) {
          timerDisplay.style.color = "red";
          extendBtn.style.display = 'inline-block';
          extendBtn.disabled = false;
          extendBtn.textContent = 'å»¶é•·ã™ã‚‹';
        }

        if (remaining <= 0) {
          clearInterval(timerInterval);
          statusEl.textContent = 'ğŸ“ é€šè©±æ™‚é–“ãŒçµ‚äº†ã—ã¾ã—ãŸ';
          endCall();
        }

        remaining--;
      }, 1000);
    }

    function updateExtensionInfo() {
      const left = 2 - extensionCount;
      document.getElementById('extensionInfo').textContent = `å»¶é•·å¯èƒ½å›æ•°: ${left}å›`;
    }

    function extendCall() {
      extensionCount++;
      remaining += 60;
      updateExtensionInfo();
      extendBtn.disabled = true;
      extendBtn.textContent = 'âœ… 1åˆ†å»¶é•·ã—ã¾ã—ãŸ';
      statusEl.textContent = 'âœ… é€šè©±ãŒ1åˆ†å»¶é•·ã•ã‚Œã¾ã—ãŸ';
      statusEl.style.color = 'green';

      if (extensionCount >= 2) {
        extendBtn.style.display = 'none';
      }

      extensionRequested = false;
      extensionReceived = false;
    }

    extendBtn.addEventListener('click', () => {
      if (extensionCount >= 2) return;
      extensionRequested = true;
      extensionReceived = false;
      extendBtn.disabled = true;
      extendBtn.textContent = 'ç›¸æ‰‹ã®åŒæ„ã‚’å¾…ã£ã¦ã„ã¾ã™...';
      socket.emit('request-extension', roomId);
      if (extensionReceived) {
        socket.emit('approve-extension', roomId);
        extendCall();
      }
    });

    socket.on('extension-requested', () => {
      extensionReceived = true;
      if (extensionRequested) {
        socket.emit('approve-extension', roomId);
      } else {
        if (extensionCount < 2) {
          extendBtn.style.display = 'inline-block';
          extendBtn.disabled = false;
          extendBtn.textContent = 'é€šè©±ç›¸æ‰‹ãŒå»¶é•·ã‚’å¸Œæœ›ã—ã¦ã„ã¾ã™';
        }
      }
    });

    socket.on('extension-approved', () => {
      if (extensionApprovals >= extensionCount + 1) return;
      extensionApprovals++;
      extendCall();
    });

    // Pause/resume
    function updatePauseStatusDisplay(userName, isSelfPaused, isOtherPaused) {
      const label = document.getElementById('pause-label');
      const status = document.getElementById('pause-status');
      if (isSelfPaused) {
        label.textContent = 'â¸ï¸ ä¸€æ™‚åœæ­¢ä¸­ã§ã™';
        status.style.display = 'block';
      } else if (isOtherPaused) {
        label.textContent = `â¸ï¸ ${userName}ã•ã‚“ãŒä¸€æ™‚åœæ­¢ä¸­ã§ã™`;
        status.style.display = 'block';
      } else {
        status.style.display = 'none';
      }
    }

    function startPauseCountdown() {
      pauseInterval = setInterval(() => {
        if (remainingPauseTime > 0) {
          remainingPauseTime--;
          const m = Math.floor(remainingPauseTime / 60);
          const s = remainingPauseTime % 60;
          document.getElementById('myPauseTimeLeft').textContent = `${m}:${s.toString().padStart(2, '0')}`;
          socket.emit('pause-time-update', { roomId, remainingPauseTime });
        } else {
          clearInterval(pauseInterval);
          timerPaused = false;
          socket.emit('resume', roomId);
          updatePauseStatusDisplay(null, false, false);
          resumeBtn.style.display = 'none';
          pauseBtn.style.display = 'inline-block';
        }
      }, 1000);
    }

    pauseBtn.addEventListener('click', () => {
      if (remainingPauseTime <= 0) return;
      socket.emit('pause', { roomId, username: "<%= user.username %>" });
      timerPaused = true;
      updatePauseStatusDisplay(null, true, false);
      startPauseCountdown();
      pauseBtn.style.display = 'none';
      resumeBtn.style.display = 'inline-block';
    });

    resumeBtn.addEventListener('click', () => {
      socket.emit('resume', roomId);
      timerPaused = false;
      updatePauseStatusDisplay(null, false, false);
      clearInterval(pauseInterval);
      resumeBtn.style.display = 'none';
      pauseBtn.style.display = 'inline-block';
    });

    socket.on('partner-paused', (name) => {
      timerPaused = true;
      updatePauseStatusDisplay(name, false, true);
      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
    });

    socket.on('partner-resumed', () => {
      timerPaused = false;
      updatePauseStatusDisplay(null, false, false);
      pauseBtn.disabled = false;
    });

    socket.on('pause-time-update', ({ remainingPauseTime }) => {
      const m = Math.floor(remainingPauseTime / 60);
      const s = remainingPauseTime % 60;
      document.getElementById('partnerPauseTimeLeft').textContent = `${m}:${s.toString().padStart(2, '0')}`;
    });

    // Topic Card
    sendTopicBtn.addEventListener('click', () => {
      const selected = topicSelect.value;
      if (!selected || topicLock) return;
      socket.emit('topic-selected', { roomId, topic: selected });
      topicDisplay.textContent = `ğŸ’¬ è©±é¡Œ: ${selected}`;
      topicNotice.textContent = `ãƒˆãƒ”ãƒƒã‚¯ã®å†é¸æŠã¯30ç§’å¾Œã«å¯èƒ½ã§ã™`;
      lockTopicSelection();
    });

    socket.on('topic-selected', (topic) => {
      topicDisplay.textContent = `ğŸ’¬ è©±é¡Œ: ${topic}`;
      if (!topicLock) {
        topicNotice.innerHTML = 'é€šè©±ç›¸æ‰‹ãŒä»¥ä¸‹ã®ãƒˆãƒ”ãƒƒã‚¯ã‚’é¸ã³ã¾ã—ãŸï¼<br>å†é¸æŠã¯30ç§’å¾Œã«å¯èƒ½ã§ã™';
        lockTopicSelection();
      }
    });

    function lockTopicSelection() {
      topicLock = true;
      sendTopicBtn.disabled = true;
      topicSelect.disabled = true;
      setTimeout(() => {
        topicLock = false;
        sendTopicBtn.disabled = false;
        topicSelect.disabled = false;
        topicNotice.textContent = '';
      }, 30000);
    }

    // WebRTC
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(stream => {
        stream.getTracks().forEach(track => peer.addTrack(track, stream));
        peer.ontrack = (event) => {
          setTimeout(() => {
            if (!remoteAudio.srcObject || remoteAudio.srcObject.getAudioTracks().length === 0) {
              alert("ç›¸æ‰‹ã®æ¥ç¶šãŒç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«æˆ»ã‚Šã¾ã™ã€‚");
              window.location.href = "/dashboard";
            }
          }, 15000);


          remoteAudio.srcObject = event.streams[0];
          statusEl.textContent = 'âœ… é€šè©±ãŒå§‹ã¾ã‚Šã¾ã—ãŸï¼';
          statusEl.style.color = 'green';
          endCallBtn.disabled = false;
          startTimer();
        };
        socket.emit('join-room', roomId);
        socket.on('ready', async () => {
          const offer = await peer.createOffer();
          await peer.setLocalDescription(offer);
          socket.emit('offer', roomId, offer);
        });
        socket.on('offer', async (offer) => {
          await peer.setRemoteDescription(offer);
          const answer = await peer.createAnswer();
          await peer.setLocalDescription(answer);
          socket.emit('answer', roomId, answer);
        });
        socket.on('answer', async (answer) => {
          await peer.setRemoteDescription(answer);
        });
        socket.on('ice-candidate', async (candidate) => {
          if (candidate) await peer.addIceCandidate(candidate);
        });
        peer.onicecandidate = (event) => {
          if (event.candidate) socket.emit('ice-candidate', roomId, event.candidate);
        };
        socket.on('force-end', () => {
          endCall();
        });
      })
      .catch(err => {
        console.error("ãƒã‚¤ã‚¯å–å¾—å¤±æ•—:", err);
      });

    // ãƒ‡ãƒã‚¤ã‚¹åˆ‡ã‚Šæ›¿ãˆ
    async function initDeviceSelectors() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(d => d.kind === 'audioinput');
        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

        micSelect.innerHTML = '';
        speakerSelect.innerHTML = '';

        audioInputs.forEach(d => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `ãƒã‚¤ã‚¯ (${d.deviceId})`;
          micSelect.appendChild(opt);
        });

        audioOutputs.forEach(d => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ (${d.deviceId})`;
          speakerSelect.appendChild(opt);
        });

        const savedMic = localStorage.getItem('preferredMic');
        const savedSpeaker = localStorage.getItem('preferredSpeaker');
        if (savedMic) {
          micSelect.value = savedMic;
          await switchMic(savedMic);
        }
        if (savedSpeaker) {
          speakerSelect.value = savedSpeaker;
          await switchSpeaker(savedSpeaker);
        }
      } catch (e) {
        console.error("ãƒ‡ãƒã‚¤ã‚¹å–å¾—å¤±æ•—:", e);
      }
    }

    async function switchMic(deviceId) {
      try {
        const newStream = await navigator.mediaDevices.getUserMedia({
          audio: { deviceId: { exact: deviceId } }
        });
        const newTrack = newStream.getAudioTracks()[0];
        const sender = peer.getSenders().find(s => s.track.kind === 'audio');
        if (sender) sender.replaceTrack(newTrack);
        if (currentStream) currentStream.getTracks().forEach(t => t.stop());
        currentStream = newStream;
      } catch (e) {
        console.error("ãƒã‚¤ã‚¯åˆ‡æ›¿å¤±æ•—:", e);
      }
    }

    async function switchSpeaker(deviceId) {
      if (typeof remoteAudio.setSinkId === 'function') {
        try {
          await remoteAudio.setSinkId(deviceId);
        } catch (e) {
          console.error("ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼åˆ‡æ›¿å¤±æ•—:", e);
        }
      } else {
        console.warn("setSinkId éå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶");
      }
    }

    micSelect.addEventListener('change', () => {
      const selected = micSelect.value;
      localStorage.setItem('preferredMic', selected);
      switchMic(selected);
    });

    speakerSelect.addEventListener('change', () => {
      const selected = speakerSelect.value;
      localStorage.setItem('preferredSpeaker', selected);
      switchSpeaker(selected);
    });

    speakerVolumeSlider.addEventListener('input', () => {
      remoteAudio.volume = parseFloat(speakerVolumeSlider.value);
    });

    initDeviceSelectors();

    socket.on('matching-error', (data) => {
      alert(data.message || 'äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      console.error('ğŸ“› ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼è©³ç´°:', data.detail);
    });

      // âœ… ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã«ã‚‚ /mark-ended ã‚’é€ä¿¡ï¼ˆé€šè©±ãŒçµ‚äº†æ¸ˆã¿ã§ãªã„å ´åˆï¼‰
  window.addEventListener('beforeunload', async (e) => {
    if (!window.__callEnded) {
      try {
        await fetch('/mark-ended', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roomId })
        });
        console.log('ğŸ“¤ beforeunload: /mark-ended æˆåŠŸ');
      } catch (err) {
        console.warn('âš ï¸ beforeunload: /mark-ended ã‚¨ãƒ©ãƒ¼:', err);
      }
    }
  });

  </script>
</body>
</html>
